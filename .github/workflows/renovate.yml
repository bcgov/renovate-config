name: Renovate

# Run on pull requests, cronjob or manually (dispatch)
on:
  pull_request:
  schedule: [cron: "0 10 * * *"] # 2 AM PST = 10 AM UDT
  workflow_dispatch:
    inputs:
      repos: # Optional input
        description: "List of repos (org/repo)"
        type: string
        required: false
      log_level: # Default input
        description: "Log level"
        default: "INFO"
        type: choice
        required: true
        options: ["INFO", "WARNING", "DEBUG"]


# Cancel any other workflows (PR, cron or manual)
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

permissions: {}

jobs:
  validate:
    name: Validate Config
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Schema validation
        run: |
          echo "üîç Stage 1: Schema validation..."
          npx --yes --package renovate --- "renovate-config-validator --strict default.json renovate.json rules-*.json5"

      - name: Config resolution test
        run: |
          echo "üîç Stage 2: Config resolution test..."
          # Skip config resolution test in CI as it requires GitHub token
          # This test is primarily for local development validation
          echo "‚úÖ Config resolution test skipped (requires GitHub token)"
          echo "  This test validates that the config can be resolved by Renovate"
          echo "  It will be tested during the actual dry-run in the next job"

      - name: Custom rule validation
        run: |
          echo "üîç Stage 3: Custom rule validation..."
          
          # Check for pinning strategy
          echo "  Checking pinning strategy..."
          if grep -q '"pinDigests": true' default.json rules-*.json5 2>/dev/null && grep -q '"pinDigests": false' default.json rules-*.json5 2>/dev/null; then
            echo "‚úÖ Pinning strategy: Global pin with specific unpins"
            echo "  This is our intended strategy - pin globally, unpin specific managers"
            
            # Check for potential conflicts - same managers with both true and false
            echo "  Checking for pinning conflicts..."
            if command -v jq >/dev/null 2>&1; then
              PIN_MANAGERS=$(jq -r '.packageRules[] | select(.pinDigests == true) | .matchManagers[]?' default.json rules-*.json5 2>/dev/null | sort | uniq || true)
              UNPIN_MANAGERS=$(jq -r '.packageRules[] | select(.pinDigests == false) | .matchManagers[]?' default.json rules-*.json5 2>/dev/null | sort | uniq || true)
            else
              echo "‚ö†Ô∏è  jq not found. Skipping pinning conflict check."
              PIN_MANAGERS=""
              UNPIN_MANAGERS=""
            fi
            
            CONFLICTS=$(comm -12 <(echo "$PIN_MANAGERS" | sort) <(echo "$UNPIN_MANAGERS" | sort) || true)
            if [ -n "$CONFLICTS" ]; then
              echo "‚ö†Ô∏è  Found managers with both pin and unpin rules:"
              echo "  $CONFLICTS"
              echo "  Checking if these are intentional exclusions..."
              
              # Check if the conflicts are intentional (pin with exclusions + unpin specific packages)
              INTENTIONAL_CONFLICTS=""
              for manager in $CONFLICTS; do
                PIN_RULES=$(jq -r --arg mgr "$manager" '.packageRules[] | select(.matchManagers[]? == $mgr and .pinDigests == true) | .matchPackageNames[]?' default.json rules-*.json5 2>/dev/null || true)
                UNPIN_RULES=$(jq -r --arg mgr "$manager" '.packageRules[] | select(.matchManagers[]? == $mgr and .pinDigests == false) | .matchPackageNames[]?' default.json rules-*.json5 2>/dev/null || true)
                
                if [ -n "$PIN_RULES" ] && [ -n "$UNPIN_RULES" ]; then
                  echo "  ‚úÖ $manager: Intentional pin with exclusions + unpin specific packages"
                else
                  INTENTIONAL_CONFLICTS="$INTENTIONAL_CONFLICTS $manager"
                fi
              done
              
              if [ -n "$INTENTIONAL_CONFLICTS" ]; then
                echo "‚ùå CONFLICT: Unresolved conflicts for managers: $INTENTIONAL_CONFLICTS"
                echo "  This will cause unpredictable behavior - fix the conflicts!"
                exit 1
              else
                echo "‚úÖ All conflicts are intentional exclusions"
              fi
            else
              echo "‚úÖ No pinning conflicts detected"
            fi
          elif grep -q '"pinDigests": true' default.json rules-*.json5 2>/dev/null; then
            echo "‚úÖ Pinning strategy: Global pinning enabled"
          elif grep -q '"pinDigests": false' default.json rules-*.json5 2>/dev/null; then
            echo "‚úÖ Pinning strategy: Specific unpinning rules"
          else
            echo "‚ö†Ô∏è  No pinning rules found"
          fi
          
          # Check for duplicate package rules
          echo "  Checking for duplicate package rules..."
          DUPLICATE_RULES=$(grep -h '"matchPackageNames"' default.json rules-*.json5 2>/dev/null | sort | uniq -d || true)
          if [ -n "$DUPLICATE_RULES" ]; then
            echo "‚ö†Ô∏è  Potential duplicate package rules found:"
            echo "$DUPLICATE_RULES"
            echo "  Review these rules to ensure they don't conflict"
          else
            echo "‚úÖ No duplicate package rules detected"
          fi
          
          # Check for valid update types
          echo "  Checking for valid update types..."
          UPDATE_TYPES=$(grep -h '"matchUpdateTypes"' default.json rules-*.json5 2>/dev/null | sed -n 's/.*"matchUpdateTypes"[[:space:]]*:[[:space:]]*\[\([^]]*\)\].*/\1/p' || true)
          if [ -n "$UPDATE_TYPES" ]; then
            echo "‚úÖ Found update types: $UPDATE_TYPES"
            INVALID_TYPES=$(echo "$UPDATE_TYPES" | grep -o '"[^"]*"' | grep -v -E '"(major|minor|patch|pin|pinDigest|digest|lockFileMaintenance|rollback|bump|replacement)"' || true)
            if [ -n "$INVALID_TYPES" ]; then
              echo "‚ùå Invalid update types found: $INVALID_TYPES"
              echo "  Valid types are: major, minor, patch, pin, pinDigest, digest, lockFileMaintenance, rollback, bump, replacement"
              exit 1
            fi
          else
            echo "‚úÖ No update type restrictions found"
          fi
          
          # Check for invalid commitMessageAction values
          echo "  Checking for invalid commitMessageAction values..."
          INVALID_COMMIT_ACTIONS=$(grep -h '"commitMessageAction":[[:space:]]*"[^"]*"' default.json rules-*.json5 2>/dev/null | grep -o '"[^"]*"$' | grep -v -E '"(replace|append|prepend)"' || true)
          if [ -n "$INVALID_COMMIT_ACTIONS" ]; then
            echo "‚ùå Invalid commitMessageAction values found:"
            echo "$INVALID_COMMIT_ACTIONS"
            echo "  Valid values are: replace, append, prepend"
            exit 1
          else
            echo "‚úÖ All commitMessageAction values are valid"
          fi
          
          # Check for contradictory enabled: true with blocking properties
          echo "  Checking for contradictory enabled: true with blocking properties..."
          CONTRADICTORY_RULES=$(grep -A5 -B5 '"enabled": true' default.json rules-*.json5 2>/dev/null | grep -E '(commitMessageAction.*block|commitMessageTopic.*block|prBody.*blocked)' || true)
          if [ -n "$CONTRADICTORY_RULES" ]; then
            echo "‚ùå Found enabled: true with blocking properties:"
            echo "$CONTRADICTORY_RULES"
            echo "  Use enabled: false to block updates, not enabled: true with blocking properties"
            exit 1
          else
            echo "‚úÖ No contradictory enabled/blocking combinations"
          fi

      - name: Integration test
        run: |
          echo "üîç Stage 4: Integration test..."
          echo "  Testing config against bcgov/quickstart-openshift..."
          
          # Skip integration test in CI as it requires GitHub token
          # This test validates that the config works with a real repository
          echo "‚úÖ Integration test skipped (requires GitHub token)"
          echo "  This test validates that the config works with real repositories"
          echo "  It will be tested during the actual dry-run in the next job"

      - name: Best practices check
        run: |
          echo "üîç Stage 5: Best practices check..."
          
          # Check for excessive grouping
          GROUP_COUNT=$(grep -h '"groupName"' default.json rules-*.json5 2>/dev/null | wc -l || echo "0")
          if [ "$GROUP_COUNT" -gt 10 ]; then
            echo "‚ö†Ô∏è  High number of grouping rules ($GROUP_COUNT)"
            echo "  Consider if all groupings are necessary"
          else
            echo "‚úÖ Grouping rules count looks reasonable ($GROUP_COUNT)"
          fi
          
          # Check for clear descriptions
          UNDESCRIBED_RULES=$(grep -h '"description"' default.json rules-*.json5 2>/dev/null | wc -l || echo "0")
          TOTAL_RULES=$(grep -h '"packageRules"' default.json rules-*.json5 2>/dev/null | wc -l || echo "0")
          if [ "$UNDESCRIBED_RULES" -lt "$TOTAL_RULES" ]; then
            echo "‚ö†Ô∏è  Some rules may be missing descriptions"
            echo "  Consider adding descriptions to all package rules"
          else
            echo "‚úÖ All rules have descriptions"
          fi
          
          # Check for rule complexity
          echo "  Checking rule complexity..."
          COMPLEX_RULES=$(awk '
            /"packageRules"/ {inblock=1}
            inblock {block=block $0 "\n"}
            /}/ && inblock {
              inblock=0
              if (block ~ /"matchManagers"/ && (block ~ /"matchPackageNames"/ || block ~ /"matchUpdateTypes"/ || block ~ /"matchCurrentVersion"/ || block ~ /"allowedVersions"/)) {
                count++
              }
              block=""
            }
            END {print count+0}
          ' default.json rules-*.json5 2>/dev/null)
          if [ "$COMPLEX_RULES" -gt 10 ]; then
            echo "‚ö†Ô∏è  Some rules have many conditions ($COMPLEX_RULES)"
            echo "  Consider simplifying complex rules for better maintainability"
          else
            echo "‚úÖ Rule complexity looks reasonable"
          fi
          
          # Check for potential performance optimizations
          echo "  Checking for performance optimizations..."
          if ! command -v jq >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  jq not found. Skipping advanced rule consolidation check."
          else
            # Use jq for JSON files and node with json5 for JSON5 files
            SIMILAR_RULES=$(node -e "
              const json5 = require('json5');
              const fs = require('fs');
              
              // Parse JSON files with jq
              const defaultJson = JSON.parse(fs.readFileSync('default.json', 'utf8'));
              
              // Parse JSON5 files with json5
              const rulesFiles = ['rules-actions.json5', 'rules-java.json5', 'rules-javascript.json5', 'rules-python.json5'];
              const allRules = [defaultJson.packageRules || []];
              
              rulesFiles.forEach(file => {
                try {
                  const content = fs.readFileSync(file, 'utf8');
                  const parsed = json5.parse(content);
                  allRules.push(parsed.packageRules || []);
                } catch (e) {
                  console.error('Error parsing ' + file + ':', e.message);
                }
              });
              
              // Flatten and group by matchManagers
              const flattened = allRules.flat();
              const grouped = {};
              
              flattened.forEach(rule => {
                if (rule.matchManagers && Array.isArray(rule.matchManagers)) {
                  rule.matchManagers.forEach(manager => {
                    if (!grouped[manager]) grouped[manager] = [];
                    grouped[manager].push(rule);
                  });
                }
              });
              
              // Find groups with multiple rules
              const similar = Object.entries(grouped)
                .filter(([manager, rules]) => rules.length > 1)
                .map(([manager, rules]) => ({
                  matchManagers: manager,
                  count: rules.length,
                  rules: rules.map(r => r.description || 'No description')
                }));
              
              if (similar.length > 0) {
                console.log('‚ö†Ô∏è  Potential rule consolidation opportunities:');
                similar.slice(0, 3).forEach(group => {
                  console.log('  Managers:', group.matchManagers);
                  console.log('    Count:', group.count);
                  console.log('    Descriptions:', group.rules.join(', '));
                });
                console.log('  Consider combining rules with similar managers for better performance, if other conditions allow.');
              } else {
                console.log('‚úÖ No obvious rule consolidation opportunities');
              }
            " 2>/dev/null)
          fi
          
          echo "üéâ Enhanced validation completed successfully!"
          echo "The Renovate configuration appears to be valid and well-structured."

      - name: Lint Config for Duplicates
        run: |
          npm install json5@^2.2.3 --no-save
          node lint_renovate_duplicates.mjs *.json *.json5

  run:
    name: Dry-Run
    needs: validate
    env:
      pr_set: bcgov/renovate-config bcgov/quickstart-openshift
    permissions:
      pull-requests: write
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v5

        # Run Renovate, dry run
      - name: Renovate Dry-Run
        run: |
          # Process repo list and add to config
          IFS=', ' read -a INPUT <<< "${{ inputs.repos || env.pr_set }}"
          for r in "${INPUT[@]}"; do
            REPOS+="\"$r\","
          done
          REPOS=${REPOS%,*}
          cat <<< $(jq '. | .repositories = ['${REPOS}']' renovate.json) > renovate.json

          # Dry run
          cat <<< $(jq '.+= {"dryRun": "full"}' renovate.json) > renovate.json

      # Run Renovate
      - name: Run Renovate
        uses: renovatebot/github-action@b11417b9eaac3145fe9a8544cee66503724e32b6 # v43.0.8
        env:
          LOG_LEVEL: ${{ inputs.log_level || 'INFO' }}
        with:
          configurationFile: renovate.json
          token: ${{ secrets.RENOVATE_TOKEN }}
